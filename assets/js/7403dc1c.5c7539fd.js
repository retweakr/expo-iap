"use strict";(globalThis.webpackChunkexpo_iap_docs=globalThis.webpackChunkexpo_iap_docs||[]).push([[7482],{6730:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"guides/subscription-validation","title":"Subscription Validation","description":"Understand how React Native IAP surfaces StoreKit 2 subscription data, from getAvailablePurchases to the StoreKit status API.","source":"@site/docs/guides/subscription-validation.md","sourceDirName":"guides","slug":"/guides/subscription-validation","permalink":"/expo-iap/docs/guides/subscription-validation","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/expo-iap/tree/main/docs/docs/guides/subscription-validation.md","tags":[],"version":"current","frontMatter":{"id":"subscription-validation","title":"Subscription Validation","sidebar_label":"Subscription Validation","description":"Understand how React Native IAP surfaces StoreKit 2 subscription data, from getAvailablePurchases to the StoreKit status API."},"sidebar":"tutorialSidebar","previous":{"title":"Subscription Offers","permalink":"/expo-iap/docs/guides/subscription-offers"},"next":{"title":"Offer Code Redemption","permalink":"/expo-iap/docs/guides/offer-code-redemption"}}');var n=s(4848),r=s(8453);const o={id:"subscription-validation",title:"Subscription Validation",sidebar_label:"Subscription Validation",description:"Understand how React Native IAP surfaces StoreKit 2 subscription data, from getAvailablePurchases to the StoreKit status API."},c=void 0,a={},d=[{value:"Summary of key surfaces",id:"summary-of-key-surfaces",level:2},{value:"Working with <code>getAvailablePurchases</code>",id:"working-with-getavailablepurchases",level:2},{value:"Data included",id:"data-included",level:3},{value:"Limitations",id:"limitations",level:3},{value:"Using <code>getActiveSubscriptions</code>",id:"using-getactivesubscriptions",level:2},{value:"Deriving a lightweight phase without <code>subscriptionStatusIOS</code>",id:"deriving-a-lightweight-phase-without-subscriptionstatusios",level:3},{value:"Phase reference",id:"phase-reference",level:3},{value:"Relationship with other APIs",id:"relationship-with-other-apis",level:3},{value:"Server-side validation and trials",id:"server-side-validation-and-trials",level:2},{value:"Putting everything together",id:"putting-everything-together",level:2}];function l(e){const i={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.p,{children:["React Native IAP exposes modern StoreKit\xa02 (iOS) and Google Play Billing (Android) pipelines. This guide walks through the data that is available on the JavaScript side, how it maps to the underlying native APIs, and practical strategies to answer common lifecycle questions such as ",(0,n.jsx)(i.em,{children:'"is the user currently inside their free trial?"'})]}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsxs)(i.p,{children:["iOS and Android share the same high-level API surface, but individual capabilities differ. Notes in each section call out platform-specific behaviour\u2014for example, ",(0,n.jsx)(i.code,{children:"subscriptionStatusIOS"})," only exists on Apple platforms, whereas Android relies on Purchase objects and the Play Developer API."]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"summary-of-key-surfaces",children:"Summary of key surfaces"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Capability"}),(0,n.jsx)(i.th,{children:"API"}),(0,n.jsx)(i.th,{children:"iOS"}),(0,n.jsx)(i.th,{children:"Android"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Fetch latest entitlement records the store still considers active"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.a,{href:"/expo-iap/docs/api/methods/core-methods#getavailablepurchases",children:(0,n.jsx)(i.code,{children:"getAvailablePurchases"})})}),(0,n.jsxs)(i.td,{children:["Wraps StoreKit\xa02 ",(0,n.jsx)(i.code,{children:"Transaction.currentEntitlements"}),"; optional flags control listener mirror & active-only filtering"]}),(0,n.jsxs)(i.td,{children:["Queries Play Billing twice (",(0,n.jsx)(i.code,{children:"inapp"})," + ",(0,n.jsx)(i.code,{children:"subs"}),") and merges validated purchases, exposing ",(0,n.jsx)(i.code,{children:"purchaseToken"})," for server use"]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Filter entitlements down to subscriptions only"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.a,{href:"/expo-iap/docs/api/methods/core-methods#getactivesubscriptions",children:(0,n.jsx)(i.code,{children:"getActiveSubscriptions"})})}),(0,n.jsxs)(i.td,{children:["Adds ",(0,n.jsx)(i.code,{children:"expirationDateIOS"}),", ",(0,n.jsx)(i.code,{children:"daysUntilExpirationIOS"}),", ",(0,n.jsx)(i.code,{children:"environmentIOS"})," convenience fields"]}),(0,n.jsxs)(i.td,{children:["Re-shapes merged purchase list and surfaces ",(0,n.jsx)(i.code,{children:"autoRenewingAndroid"}),", ",(0,n.jsx)(i.code,{children:"purchaseToken"}),", and ",(0,n.jsx)(i.code,{children:"willExpireSoon"})," placeholders"]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Inspect fine-grained subscription phase"}),(0,n.jsx)(i.td,{children:(0,n.jsx)(i.a,{href:"/expo-iap/docs/api/methods/core-methods#subscriptionstatusios",children:(0,n.jsx)(i.code,{children:"subscriptionStatusIOS"})})}),(0,n.jsxs)(i.td,{children:["StoreKit\xa02 status API (",(0,n.jsx)(i.code,{children:"inTrialPeriod"}),", ",(0,n.jsx)(i.code,{children:"inGracePeriod"}),", etc.)"]}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.em,{children:"Not available"}),"; pair ",(0,n.jsx)(i.code,{children:"getAvailablePurchases"})," with Play Developer API (",(0,n.jsx)(i.code,{children:"purchases.subscriptions"}),"/",(0,n.jsx)(i.code,{children:"purchases.products"}),") for phase data"]})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:"Retrieve receipts for validation"}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.a,{href:"/expo-iap/docs/api/methods/core-methods#getreceiptdataios",children:(0,n.jsx)(i.code,{children:"getReceiptDataIOS"})}),", ",(0,n.jsx)(i.a,{href:"/expo-iap/docs/api/methods/core-methods#validatereceiptios",children:(0,n.jsx)(i.code,{children:"validateReceipt"})})]}),(0,n.jsx)(i.td,{children:"Provides App Store receipt / JWS for backend validation"}),(0,n.jsxs)(i.td,{children:[(0,n.jsx)(i.code,{children:"validateReceipt"})," forwards to OpenIAP\u2019s Google Play validator and expects ",(0,n.jsx)(i.code,{children:"purchaseToken"})," / ",(0,n.jsx)(i.code,{children:"packageName"})]})]})]})]}),"\n",(0,n.jsxs)(i.h2,{id:"working-with-getavailablepurchases",children:["Working with ",(0,n.jsx)(i.code,{children:"getAvailablePurchases"})]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"getAvailablePurchases"})," returns every purchase that the native store still considers ",(0,n.jsx)(i.em,{children:"active"})," for the signed-in user."]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"iOS"})," \u2014 The library bridges directly to StoreKit\xa02\u2019s ",(0,n.jsx)(i.code,{children:"Transaction.currentEntitlements"}),", so each item is a fully validated ",(0,n.jsx)(i.code,{children:"PurchaseIOS"}),". Optional flags (",(0,n.jsx)(i.code,{children:"onlyIncludeActiveItemsIOS"}),", ",(0,n.jsx)(i.code,{children:"alsoPublishToEventListenerIOS"}),") are forwarded to StoreKit and mimic the native behaviour."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Android"})," \u2014 Google Play Billing keeps one list for in-app products and another for subscriptions. The React Native IAP wrapper automatically queries both (",(0,n.jsx)(i.code,{children:"type: 'inapp'"})," and ",(0,n.jsx)(i.code,{children:"type: 'subs'"}),"), merges the results, and validates them before returning control to JavaScript."]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"Because the data flows through the same validation pipeline as the purchase listeners, every element in the array has the same shape you receive when a new transaction comes in."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-tsx",children:"import {useEffect} from 'react';\nimport {useIAP} from 'react-native-iap';\n\nexport function SubscriptionGate({subscriptionId}: {subscriptionId: string}) {\n  const {getAvailablePurchases, availablePurchases} = useIAP();\n\n  useEffect(() => {\n    getAvailablePurchases([subscriptionId]);\n  }, [getAvailablePurchases, subscriptionId]);\n\n  const active = availablePurchases.some(\n    (purchase) => purchase.productId === subscriptionId,\n  );\n\n  // ...render locked/unlocked UI...\n}\n"})}),"\n",(0,n.jsx)(i.h3,{id:"data-included",children:"Data included"}),"\n",(0,n.jsx)(i.p,{children:"For each purchase you can inspect fields such as:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"expirationDateIOS"}),": milliseconds since epoch when the current period expires"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"isAutoRenewing"}),": whether auto-renew is still enabled"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"offerIOS"}),": original offer metadata (",(0,n.jsx)(i.code,{children:"paymentMode"}),", ",(0,n.jsx)(i.code,{children:"period"}),", etc.)"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"environmentIOS"}),": ",(0,n.jsx)(i.code,{children:"Sandbox"})," or ",(0,n.jsx)(i.code,{children:"Production"})]}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"limitations",children:"Limitations"}),"\n",(0,n.jsxs)(i.p,{children:["StoreKit does ",(0,n.jsx)(i.strong,{children:"not"}),' bake "current phase" indicators into these records\u2014',(0,n.jsx)(i.code,{children:"offerIOS.paymentMode"}),' tells you which introductory offer was used initially, but does not tell you whether the user is still inside that offer window. To answer questions like "is the user still in a free trial?" you need either the StoreKit status API or server-side receipt validation.']}),"\n",(0,n.jsxs)(i.h2,{id:"using-getactivesubscriptions",children:["Using ",(0,n.jsx)(i.code,{children:"getActiveSubscriptions"})]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"/expo-iap/docs/api/methods/core-methods#getactivesubscriptions",children:(0,n.jsx)(i.code,{children:"getActiveSubscriptions"})})," is a thin helper that filters ",(0,n.jsx)(i.code,{children:"getAvailablePurchases"})," down to subscription products. It returns an array of ",(0,n.jsx)(i.code,{children:"ActiveSubscription"})," objects with convenience fields:"]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"isActive"}),": always ",(0,n.jsx)(i.code,{children:"true"})," as long as the subscription remains in the current entitlement set"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"expirationDateIOS"})," & ",(0,n.jsx)(i.code,{children:"daysUntilExpirationIOS"}),": surfaced directly from StoreKit"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"transactionId"})," / ",(0,n.jsx)(i.code,{children:"purchaseToken"}),": handy for reconciling with receipts or Play Billing"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"willExpireSoon"}),": flag set by the helper when the subscription is within its grace window"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"autoRenewingAndroid"}),": reflects the Google Play auto-renew status for subscriptions"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"environmentIOS"}),": tells you whether the entitlement came from ",(0,n.jsx)(i.code,{children:"Sandbox"})," or ",(0,n.jsx)(i.code,{children:"Production"})]}),"\n"]}),"\n",(0,n.jsxs)(i.p,{children:["The helper does ",(0,n.jsx)(i.strong,{children:"not"})," fetch additional metadata beyond what ",(0,n.jsx)(i.code,{children:"getAvailablePurchases"})," already provides. It exists to make stateful hooks easier to consume."]}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.strong,{children:"Platform note:"})," On iOS the helper simply re-shapes the StoreKit\xa02 entitlement objects. On Android it operates on the merged ",(0,n.jsx)(i.code,{children:"inapp"})," + ",(0,n.jsx)(i.code,{children:"subs"})," purchase list returned by Play Billing, so the output always contains both one-time products and subscriptions unless you pass specific product IDs."]}),"\n"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-ts",children:"import {getActiveSubscriptions} from 'react-native-iap';\n\nconst active = await getActiveSubscriptions(['your.yearly.subscription']);\nif (active.length === 0) {\n  // user has no valid subscription\n}\n"})}),"\n",(0,n.jsxs)(i.h3,{id:"deriving-a-lightweight-phase-without-subscriptionstatusios",children:["Deriving a lightweight phase without ",(0,n.jsx)(i.code,{children:"subscriptionStatusIOS"})]}),"\n",(0,n.jsxs)(i.p,{children:["If you want a coarse subscription phase that works the same way on iOS and Android, you can compute it from the entitlement cache that backs ",(0,n.jsx)(i.code,{children:"getActiveSubscriptions"}),"."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-ts",children:"import {getActiveSubscriptions} from 'react-native-iap';\n\nconst MS_IN_DAY = 1000 * 60 * 60 * 24;\nconst GRACE_WINDOW_DAYS = 3;\n\ntype DerivedPhase = 'subscribed' | 'expiringSoon' | 'expired';\n\nexport async function getCurrentPhase(sku: string): Promise<DerivedPhase> {\n  const subscriptions = await getActiveSubscriptions([sku]);\n  const entry = subscriptions.find((sub) => sub.productId === sku);\n\n  if (!entry) {\n    return 'expired';\n  }\n\n  const now = Date.now();\n  const expiresAt = entry.expirationDateIOS ?? null;\n\n  if (\n    typeof entry.daysUntilExpirationIOS === 'number' &&\n    entry.daysUntilExpirationIOS <= 0\n  ) {\n    return 'expired';\n  }\n\n  if (expiresAt && expiresAt <= now) {\n    return 'expired';\n  }\n\n  const graceWindowMs = GRACE_WINDOW_DAYS * MS_IN_DAY;\n  if (\n    (expiresAt && expiresAt - now <= graceWindowMs) ||\n    (typeof entry.daysUntilExpirationIOS === 'number' &&\n      entry.daysUntilExpirationIOS * MS_IN_DAY <= graceWindowMs) ||\n    entry.autoRenewingAndroid === false\n  ) {\n    return 'expiringSoon';\n  }\n\n  return 'subscribed';\n}\n"})}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsxs)(i.p,{children:["Tweak ",(0,n.jsx)(i.code,{children:"GRACE_WINDOW_DAYS"})," (or add additional checks such as ",(0,n.jsx)(i.code,{children:"willExpireSoon"}),') to match how your product defines "grace period". For Android plans you can also look at ',(0,n.jsx)(i.code,{children:"autoRenewingAndroid"})," and the Play Developer API for richer state."]}),"\n"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"\n## StoreKit 2 status API (`subscriptionStatusIOS`)\n\nWhen you need to know the exact lifecycle phase, call [`subscriptionStatusIOS`](../api/methods/core-methods.md#subscriptionstatusios). This maps to StoreKit&nbsp;2\u2019s `Product.SubscriptionInfo.Status` API and returns an array of status entries for the subscription group. Each `status.state` comes through as a string so you can forward unknown values to your analytics or logging when Apple adds new phases.\n\n```ts\nimport {subscriptionStatusIOS} from 'react-native-iap';\n\nconst statuses = await subscriptionStatusIOS('your.yearly.subscription');\nconst latestState = statuses[0]?.state ?? 'unknown';\n"})}),"\n",(0,n.jsx)(i.h3,{id:"phase-reference",children:"Phase reference"}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsxs)(i.th,{children:[(0,n.jsx)(i.code,{children:"state"})," value"]}),(0,n.jsx)(i.th,{children:"Meaning"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"subscribed"})}),(0,n.jsx)(i.td,{children:"Subscription is active and billing is up to date"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"expired"})}),(0,n.jsx)(i.td,{children:"Subscription is no longer active"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"inGracePeriod"})}),(0,n.jsx)(i.td,{children:"Auto-renewal failed but StoreKit granted a grace period before suspending access"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"inBillingRetryPeriod"})}),(0,n.jsx)(i.td,{children:"Auto-renewal failed and StoreKit is retrying the payment method"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"revoked"})}),(0,n.jsx)(i.td,{children:"Apple revoked the subscription (for example, due to customer support refunds)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"inIntroOfferPeriod"})}),(0,n.jsx)(i.td,{children:"User is currently inside a paid introductory offer (e.g., pay upfront or pay-as-you-go)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"inTrialPeriod"})}),(0,n.jsx)(i.td,{children:"User is currently in the free-trial window"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"paused"})}),(0,n.jsx)(i.td,{children:"Subscription manually paused by the user (where supported)"})]})]})]}),"\n",(0,n.jsx)(i.h3,{id:"relationship-with-other-apis",children:"Relationship with other APIs"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Use ",(0,n.jsx)(i.code,{children:"getActiveSubscriptions"})," (or the helper shown above) to keep your UI in sync with entitlement data across both platforms, then enhance it with ",(0,n.jsx)(i.code,{children:"subscriptionStatusIOS"})," when you need the StoreKit-specific phase strings."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"latestTransactionIOS"})," returns the full ",(0,n.jsx)(i.code,{children:"Purchase"})," object tied to the most recent status entry\u2014useful when storing transaction IDs on your backend."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"currentEntitlementIOS"})," shortcuts to the single entitlement for a SKU if you do not need the full array."]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"server-side-validation-and-trials",children:"Server-side validation and trials"}),"\n",(0,n.jsxs)(i.p,{children:["If you already maintain a server, Apple\u2019s ",(0,n.jsx)(i.code,{children:"/verifyReceipt"})," endpoint exposes ",(0,n.jsx)(i.code,{children:"is_trial_period"})," and ",(0,n.jsx)(i.code,{children:"is_in_intro_offer_period"})," flags for each transaction in the receipt. In newer builds, the hosted validation helper that backs ",(0,n.jsx)(i.code,{children:"validateReceipt"})," also normalises the response into a cross-platform shape so your backend sees the same fields for both stores:"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-ts",children:"// Normalised validation payload (fields shown when available)\n{\n  transactionId: '1000000000000000',\n  originalTransactionId: '1000000000000000',\n  productId: 'com.example.premium.yearly',\n  purchaseDate: 1758086400000,        // epoch ms\n  expiresDate: 1760764800000,         // epoch ms or null for non-recurring products\n  type: 'AutoRenewableSubscription',  // StoreKit or Play Billing product type\n  environment: 'Production',\n  receiptId: 'iap-rec-abcdef',        // internal receipt reference\n  appleAppStoreData?: {\n    transaction: { ... },             // StoreKit transactionData payload\n    originalTransaction: { ... }\n  },\n  googlePlayData?: {\n    rawGooglePlayResponse: { ... },   // Play Billing purchase JSON\n    expiryTimeMillis: '1760764800000'\n  }\n}\n"})}),"\n",(0,n.jsxs)(i.blockquote,{children:["\n",(0,n.jsxs)(i.p,{children:["On iOS the helper maps StoreKit 2\u2019s ",(0,n.jsx)(i.code,{children:"transactionData"})," fields (transaction ids, environment, expires date). On Android you receive the raw Play Billing response along with derived timestamps such as ",(0,n.jsx)(i.code,{children:"expiryTimeMillis"}),"."]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"We recommend the following layering:"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsxs)(i.li,{children:["Use ",(0,n.jsx)(i.code,{children:"subscriptionStatusIOS"})," for fast, on-device checks when UI needs to react immediately."]}),"\n",(0,n.jsxs)(i.li,{children:["Periodically upload receipts (via ",(0,n.jsx)(i.a,{href:"/expo-iap/docs/api/methods/core-methods#getreceiptdataios",children:(0,n.jsx)(i.code,{children:"getReceiptDataIOS"})}),") to your backend for authoritative validation and entitlement provisioning."]}),"\n",(0,n.jsxs)(i.li,{children:["Recalculate client caches (",(0,n.jsx)(i.code,{children:"getAvailablePurchases"}),") after server reconciliation to ensure consistency across devices."]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"putting-everything-together",children:"Putting everything together"}),"\n",(0,n.jsx)(i.p,{children:"A typical subscription screen in React Native IAP might:"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsxs)(i.li,{children:["Call ",(0,n.jsx)(i.code,{children:"initConnection"})," and ",(0,n.jsx)(i.code,{children:"fetchProducts"})," when mounted."]}),"\n",(0,n.jsxs)(i.li,{children:["Use ",(0,n.jsx)(i.code,{children:"useIAP"})," to observe purchase updates and update local state."]}),"\n",(0,n.jsxs)(i.li,{children:["Fetch ",(0,n.jsx)(i.code,{children:"getAvailablePurchases"})," on launch to restore entitlements."]}),"\n",(0,n.jsxs)(i.li,{children:["Query ",(0,n.jsx)(i.code,{children:"subscriptionStatusIOS"})," to display whether the user is inside a trial or grace period."]}),"\n",(0,n.jsx)(i.li,{children:"Sync receipts to your server to unlock cross-device access."}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"By combining these surfaces you can offer a reliable experience that embraces StoreKit\xa02\u2019s richer metadata while preserving backwards compatibility with existing server flows."})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,i,s)=>{s.d(i,{R:()=>o,x:()=>c});var t=s(6540);const n={},r=t.createContext(n);function o(e){const i=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);